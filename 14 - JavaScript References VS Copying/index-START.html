<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<title>JS Reference VS Copy</title>
	</head>
	<body>
		<script>
			// start with strings, numbers and booleans
			// make copy when assigned
			// let number = 3;
			// let number2 = number;
			// console.log(number, number2);
			// number = 9;
			// console.log(number, number2);

			// let name = "Raf";
			// let name2 = name;
			// console.log(name, name2);
			// name = "Bos";
			// console.log(name, name2);

			// Let's say we have an array
			// const players = ["Wes", "Sarah", "Ryan", "Poppy"];

			// and we want to make a copy of it.
			// console.log("Arrays");
			// const team = players;
			// console.log(players, team);
			// You might think we can just do something like this:
			// console.log("Arrays changed?");
			// team[3] = "Gosling";
			// console.log(players, team);
			// however what happens when we update that array?

			// now here is the problem!

			// oh no - we have edited the original array too!

			// Why? It's because that is an array reference, not an array copy. They both point to the same array!

			// So, how do we fix this? We take a copy instead!

			// one way
			// const team2 = [...players];
			// const team3 = players.slice();
			// const team4 = [].concat(players);
			// team2[3] = "team2";
			// team3[3] = "team3";
			// team4[3] = "team4";
			// console.log(players, team, team2, team3, team4);

			// or create a new array and concat the old one in

			// or use the new ES6 Spread

			// I did it first in team2
			// const team5 = Array.from(players);
			// team5[3] = "team5";
			// const team6 = new Array(...players);
			// team6[3] = "team6";

			// console.log(players, team, team2, team3, team4, team5, team6);

			// now when we update it, the original one isn't changed

			// The same thing goes for objects, let's say we have a person object

			// with Objects
			const person = {
				name: "Wes Bos",
				age: 80,
				social: {
					twitter: "@Raf",
					facebook: "@FaceRaf",
				},
			};

			// and think we make a copy:
			const newPerson = person;
			console.log(person, newPerson);
			//  THIS SUX

			// how do we take a copy instead?
			const newPerson2 = { ...person };
			// STILL SHITTY - ref type

			console.log(person, newPerson, newPerson2);
			const nP3 = Object.assign({}, person, { car: "BenZ" });

			person.name = "Rafcio";
			console.log(person, newPerson, newPerson2, nP3);

			// We will hopefully soon see the object ...spread

			// there is right now but I need to check if this makes deep clone
			const personSpread = { ...person };
			person.social.twitter = "Love";
			personSpread.social.twitter = "Hate";
			console.clear();
			console.log(person, personSpread);

			// Things to note - this is only 1 level deep - both for Arrays and Objects. lodash has a cloneDeep method, but you should think twice before using it.
		</script>
	</body>
</html>
